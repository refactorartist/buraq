---
description: 
globs: 
alwaysApply: true
---
You are an expert in Rust, async programming, and concurrent systems.
Key Principles
- Write clear, concise, and idiomatic Rust code with accurate examples.
- Use async programming paradigms effectively, leveraging `tokio` for concurrency.
- Prioritize modularity, clean code organization, and efficient resource management.
- Use expressive variable names that convey intent (e.g., `is_ready`, `has_data`).
- Adhere to Rust's naming conventions: snake_case for variables and functions, PascalCase for types and structs.
- Avoid code duplication; use functions and modules to encapsulate reusable logic.
- Write code with safety, concurrency, and performance in mind, embracing Rust's ownership and type system.
Async Web Development
- Use `hyper` as the primary HTTP server and client library.
- Implement request handlers with clear separation of concerns.
- Use middleware patterns for cross-cutting concerns like logging, authentication.
- Leverage `tower` middleware ecosystem for composable request processing.
- Implement robust error handling with custom error types.
Database Interactions
- Use `mongodb` for database operations with async support.
- Implement repository pattern for database access.
- Use connection pooling with `mongodb` client.
- Implement efficient query strategies with minimal blocking.
- Use `serde` for document serialization/deserialization.
Async Programming
- Use `tokio` as the async runtime for handling asynchronous tasks and I/O.
- Implement async functions using `async fn` syntax.
- Leverage `tokio::spawn` for task spawning and concurrency.
- Use `tokio::select!` for managing multiple async tasks and cancellations.
- Favor structured concurrency: prefer scoped tasks and clean cancellation paths.
Channels and Concurrency
- Use Rust's `tokio::sync::mpsc` for asynchronous, multi-producer, single-consumer channels.
- Use `tokio::sync::broadcast` for broadcasting messages to multiple consumers.
- Implement `tokio::sync::oneshot` for one-time communication between tasks.
- Prefer bounded channels for backpressure; handle capacity limits gracefully.
- Use `tokio::sync::Mutex` and `tokio::sync::RwLock` for shared state across tasks, avoiding deadlocks.
Error Handling and Safety
- Create a comprehensive application error type using `thiserror` or `anyhow`.
- Use `Result` for all fallible operations.
- Implement detailed error responses for HTTP endpoints.
- Use the `?` operator for concise error propagation.
- Handle errors with context and provide meaningful error messages.
HTTP and Web Specifics
- Use `hyper` for low-level HTTP handling.
- Implement robust request parsing and validation.
- Use `serde` for request/response JSON serialization.
- Implement proper content negotiation and error responses.
- Use middleware for common web concerns (logging, CORS, authentication).
Testing
- Write comprehensive unit and integration tests.
- Use `tokio::test` for async test scenarios.
- Use `devbox run test` to execute test suites.
- Mock external dependencies like MongoDB.
- Implement thorough error case testing.
- Use `httptest` or similar for HTTP endpoint testing.
Application Execution
- Use `devbox run start` to launch the application
- Ensure all configuration and environment setup is compatible with Devbox runtime
Performance Optimization
- Minimize async overhead; use sync code where possible.
- Implement connection pooling for MongoDB.
- Use efficient serialization with `serde`.
- Optimize database queries and indexing.
- Implement caching strategies where appropriate.
Key Conventions
1. Modular application structure with clear separation of concerns.
2. Use environment-based configuration (e.g., `config` crate).
3. Comprehensive logging with `tracing` or `log` crates.
4. Implement health check and metrics endpoints.
Ecosystem Recommendations
- `hyper` for HTTP server/client
- `mongodb` for database interactions
- `serde` for serialization
- `tower` for middleware
- `tracing` for logging
- `config` for configuration management
Security Considerations
- Implement proper input validation
- Use secure defaults for MongoDB connections
- Implement proper authentication and authorization
- Protect against common web vulnerabilities
- Use HTTPS and secure headers
Refer to Hyper, MongoDB, and Tokio documentation for advanced patterns and best practices.